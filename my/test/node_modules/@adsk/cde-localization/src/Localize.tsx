/**
 * Localize component - handle localization of labels
 * This component is also a Mediator Component, exposing localization bundle through redux store
 */
import moment from 'moment';
import * as React from 'react';

import bundle from '../bundles/localizationBundle.json';
import bundle_cs from '../bundles/localizationBundle_cs.json';
import bundle_de from '../bundles/localizationBundle_de.json';
import bundle_es from '../bundles/localizationBundle_es.json';
import bundle_fr from '../bundles/localizationBundle_fr.json';
import bundle_it from '../bundles/localizationBundle_it.json';
import bundle_ja from '../bundles/localizationBundle_ja.json';
import bundle_ko from '../bundles/localizationBundle_ko.json';
import bundle_pl from '../bundles/localizationBundle_pl.json';
import bundle_ptBR from '../bundles/localizationBundle_pt-BR.json';
import bundle_ru from '../bundles/localizationBundle_ru.json';
import bundle_tr from '../bundles/localizationBundle_tr.json';
import bundle_zhCN from '../bundles/localizationBundle_zh-CN.json';
import bundle_zhTW from '../bundles/localizationBundle_zh-TW.json';

import {
    IMediatorComponent,
    IMediatorComponentActions,
    IMediatorComponentReducers,
    Mediator,
    MediatorComponent
} from '@adsk/cde-mediator';

import { localizeReducer } from './reducer';

/**
 * Localize component - localization of labels through component
 */
class Localize extends MediatorComponent implements IMediatorComponent {
    private static mediator: Mediator = new Mediator();
    private static localeMap: Map<String, any>;
    private actions: IMediatorComponentActions;
    private reducers: IMediatorComponentReducers;
    private packageIdentifier: string;
    /**
     * Constructor of the class Localize
     * @param ILocalize - interface defined with properties passed into this component
     */
    constructor(props: ILocalize) {
        super(props);
        this.packageIdentifier = '@adsk/cde-localization';
        this.reducers = { root: localizeReducer };
        this.actions = {};

    }

    //tslint:disable-next-line:function-name
    public static getBundle(): any {
        const locale: string = Localize.mediator.getStore().getState()['@adsk/cde-mediator'].appLocale || '';
        const result = this.getLocaleMap().get(locale.toLowerCase());
        moment.locale(this.getMomentLocalMap(locale));

        return result ? result : bundle;
    }

    /**
     * Format date to a specified format.
     * For example: moment(date).format('LT') //  "h:mm A"
     * moment(data).format('ll') // "MMM D YYYY"
     * return an string and we can change return value in the future. all format can view in https://momentjs.com/docs/
     */
    // tslint:disable-next-line: function-name
    public static formatTime(time: string): any {
        if (!time) {
            return null;
        }

        return `${moment(time).format('LT')}`;
    }
    
    /**
     * Format date to a specified format.
     * Input date string and format format like 'lll','ll'
     * It is using function moment(data).format('ll') // "MMM D YYYY"
     * return an string. All format can view in https://momentjs.com/docs/
     */
    // tslint:disable-next-line: function-name
    public static formatDate(date: string, dateFormat: string): any {
        if (!date) {
            return null;
        }

        return `${moment(date).format(dateFormat)}`;
    }

     // tslint:disable-next-line: function-name
    public static getDayFromTime(time: string): any {
        if (!time) {
            return  null;
        }
        const locale: string = Localize.mediator.getStore().getState()['@adsk/cde-mediator'].appLocale || '';
        const notStringTime = `${moment(time).format('ll')}`;
        const today = this.getBundle().text.today || 'Today';
        const yesterday = this.getBundle().text.yesterday || 'Yesterday';
        moment.updateLocale(moment.locale(this.getMomentLocalMap(locale)), {
            calendar: {
                sameDay: `[${today}]`,
                lastDay: `[${yesterday}]`,
                sameElse: now => `[${notStringTime}]`,
                nextDay: now => `[${notStringTime}]`,
                nextWeek: now => `[${notStringTime}]`,
                lastWeek: now => `[${notStringTime}]`
            }
        });

        return `${moment(time).calendar()}`;
    }
    //tslint:disable-next-line: function-name
    public static getDataCardTimeFormat(time: string): any {
        return `${moment(time).format('LT')} ${moment(time).format('ll')}`;
    }

    private static getLocaleMap(): Map<String, any> {
        if (Localize.localeMap !== undefined) {
            return Localize.localeMap;
        }

        const map = new Map<String, any>();

        // due to no case sensitive, same localStrings will be merged
        // localeStrings from Frement have been merged to below
        // the follows are from Fusion Team(FT)
        map.set('cs-cz', bundle_cs);
        map.set('de-de', bundle_de);
        map.set('en-us', bundle);
        map.set('es-es', bundle_es);
        map.set('fr-fr', bundle_fr);
        map.set('it-it', bundle_it);
        map.set('ja-jp', bundle_ja);
        map.set('ko-kr', bundle_ko);
        map.set('pl-pl', bundle_pl);
        map.set('pt-br', bundle_ptBR);
        map.set('ru-ru', bundle_ru);
        map.set('tr-tr', bundle_tr);
        map.set('zh-cn', bundle_zhCN);
        map.set('zh-tw', bundle_zhTW);

        // the followings are from CDE
        map.set('cs', bundle_cs);
        map.set('de', bundle_de);
        map.set('es', bundle_es);
        map.set('fr', bundle_fr);
        map.set('it', bundle_it);
        map.set('ja', bundle_ja);
        map.set('ko', bundle_ko);
        map.set('pl', bundle_pl);
        map.set('ru', bundle_ru);
        map.set('tr', bundle_tr);

        Localize.localeMap = map;

        return Localize.localeMap;
    }
    /**
     * Match correct language string for moment.
     * @param local language string
     */
    private static getMomentLocalMap(local: string) {
        const momentLocal = local.toLocaleLowerCase();
        const momentLocalArray = ['cs', 'de', 'es', 'fr', 'it', 'ja', 'ko', 'pl', 'pu', 'tr'];

        return momentLocalArray.find(item => momentLocal.toLocaleLowerCase().indexOf(item) === 0) || momentLocal;
    }

    /**
     * Implement IMediatorComponent getActions
     */
    public getActions(): IMediatorComponentActions {
        return this.actions;
    }

    /**
     * Implement IMediatorComponent getReducers
     */
    public getReducers(): IMediatorComponentReducers {
        return this.reducers;
    }

    /**
     * Implement IMediatorComponent getMiddleware
     */
    public getMiddleware(): Function {
        // tslint:disable-next-line
        return args => next => action => { };
    }

    /**
     * Built-in React lifecycle callback - called when this component is mounted
     */
    public componentDidMount(): void {
        Localize.mediator.registerComponents([{ name: this.packageIdentifier, comp: this }]);
    }

    /**
     * Built-in React lifecycle callback - called for rendering of this component
     * @return A React component
     */
    public render(): React.ReactNode {
        const localizedBundle: any = Localize.getBundle();

        return (<span>{this.props.id.split('.').reduce((o: any, i: any) => o[i], localizedBundle)}</span>);
    }

}

interface ILocalize {
    id: string;
}

// tslint:disable-next-line
export default Localize;
export { ILocalize };
